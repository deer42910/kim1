**ArrayList不安全的原因**

1. 缺乏同步：add(),remove(),get()等语言都没有同步，在多线程操作同一个`arraylist`时，肯会发生数据竞争或不一致的情况
2. **内部数据结构共享**：
   - `ArrayList` 使用一个动态数组来存储元素。如果一个线程正在修改列表（例如添加或删除元素），而另一个线程也尝试访问或修改它，可能会导致数组状态不一致或 `ConcurrentModificationException` 异常。

**解决方案**

- 用Vector替代(不推荐：对应用性能有影响)

  ```
  Vector<Integer> vector = new Vector<>();
  ```

  > 内置锁：一个线性执行同步方法时，阻止其他线程同时使用这些方法。避免并发
  >
  > 同步方法：Vector类的许多方法被声明为synchronized(`add()`, `remove()`, `get()`),每次只有一个线程访问这些方法。

- 将`ArrayList`包装为同步列表

```
Collections.synchronizedList(new ArrayList<>())
```

- 使用`CopyOnWriteArrayList`

底层还是一个数组来存储数据，不过加了一个volatile修饰词，这样在操作数组的时候其他线程也能感知到。

在add方法中加了锁，通过copy阔容，将值赋值到数组末尾；读没加锁。

```
public boolean add(E e) {
        synchronized (lock) {
            Object[] es = getArray();
            int len = es.length;
            es = Arrays.copyOf(es, len + 1);
            es[len] = e;
            setArray(es);
            return true;
        }
    }
```

**volatile**

一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰后，就具备两层语义：

1. 保证线程间的可见性  

   一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的；volatile会强制将修改的值立即写入主存。

   > 主要是在JVM中有一个JIT(即时编译器)给代码做了优化，若一个操作重复执行了多次，JIT就会记住这个操作(就是循环!stop  –>  true  他会一直认为是ture  突然变为false是依然不会停止)，这是我们就要使用volatile来禁用JIT

2. 禁止指令重排序

   ```
   int x;
   volatile int y;
   
   @Actor//保证方法内代码在同一个线程下执行
   public void actor1(){
     x=1;
     y=1;
   }
   
   public void actor2(Result r){
     r.r1=y;
     r.r2=x;
   }
   不加 volatile 结果 0，0     0，1    1，1   1，0（发生指令重排，影响结果）
   ```

   ![image-20240830170656151](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240830170656151.png)

**1.8之后HashMap的实现原理**

在1.8之前，是通过数组和链表来实现的，把每一个key映射到数组上的槽，叫桶数组然后映射到相同槽的就存储在一个链表里面。但是因为当映射到同一个槽的key太多了（也就是哈希冲突），会导致变成很长的链表，那么查询的效率就非常低了。

1.8之后，当一个链表的长度超过了8，自动从链表转换成红黑树，从O(n)变成了 O(logn)，而当小于6了，又会从红黑树变成链表结构。但是要数组的容量大于64才会变成红黑树，不然会先扩容数组。

> 发生哈希冲突的概率很小，理想状态下，可以说HashMap的时间复杂度是O(1)

![image-20240831135753233](D:\a_briup_learn\面试题\集合篇\集合面试题.assets\image-20240831135753233.png)

![image-20230428204902016](D:\a_briup_learn\面试题\集合篇\集合面试题.assets\image-20230428204902016.png)

**哈希冲突的解决办法**

哈希冲突：就是当两个不同的输入经过哈希函数计算后生成相同的哈希值，这种现象被称为“哈希冲突”。哈希值取模运算之后得到的索引对于散列表中相同的槽位导致冲突。

1. 连接法：是用链表或者其他数据结构来存储冲突的键值对（HashMap）

2. 开放寻址法：发生冲突时，寻找散列表中的其他空槽来存储数据。

   - 线性探测：发生冲突，（索引加一），有冲突后移，以此类推，直到有空位。（查找效率降低）

   - 二次探测：不是线性检测，按照二次函数步长进行探测。如：索引+1^2、索引+2^2、索引+3^2…依次类推。

   - 双重散列：两个哈希函数，一个计算初始索引，若冲突，再根据第二个计算探测步长。

     ```
     index = (hashCode1 + i * hashCode2) % array.length;
     ```

     > 步长 ：1     二次函数1 2^2 3^2 …  第二个哈希函数h2、2×h2、 3×h2….

**hashMap的put方法的具体流程**

> transient关键词，用于标记某个类的字段，使得在序列化过程中被忽略。
>
> 序列化是将对象的状态转换为字节流的过程，以便于存储或传递。
>
> **对象序列化** 当对象被序列化时，标记为 `transient` 的字段不会被包含在序列化的字节流中。这意味着这些字段在序列化（写入文件ObjectOutputStream）时会被丢弃，在反序列化（读文件ObjectInputStream）时不会恢复它们的值(成默认值0..)。

![image-20240831145315195](D:\a_briup_learn\面试题\集合篇\集合面试题.assets\image-20240831145315195.png)