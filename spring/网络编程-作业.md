网络编程-作业

```
1.三次握手
    客户端->服务端发送连接请求，等待服务器确认
    服务器接收到请求并返回响应
    客户端接收到响应，向服务端发送确认信息，确认连接

    四次挥手
    client发出中断连接请求
    server返回一个响应：等待断开
    server返回一个响应：确认断开
    client正式确认断开连接
```

```
2.TCP（传输控制协议）与UDP（用户数据）协议的区别
    tcp面向连接的通信协议，即传输数据之间，在发送端和接收端建立连接，然后再传输数据，它提供了两台计算机之间可靠的、无差别的数据传输。
    比如聊天
    udp无连接通信协议，在数据传输时，数据的发送端和接收端不建立连接，不能保证数据传输的完整性，但消耗资源小，通信效率高，通常使用于音频、视频和普通数据的传输
    偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
```

```
3、注意：使用对象流(Object)注意序列化机制，你的对象必需实现Serializable接口
```

```
public class Teacher implements Serializable {
    private static final long serialVersionUID=1L;
    private String name;
    private int age;
    private double salary;
//...
}
```

```java
/**
 * 1、搭建TCP客户端
 * a.从键盘录入老师信息，录入格式：姓名-年龄-工资，遇quit结束录
 * 入
 * zs-31-8900
 * tom-28-7893.5
 * ww-33-4536.5
 * ...
 * quit
 * b.将每行信息封装成老师对象，全部发送到服务器
 * c.发送成功后，收取从服务器返回的信息并输出
 * d.最后关闭客户端
 *
 *
 * 键盘输入 Scanner new一个集合存储所有teacher
 * 将teacher集合发送给server ObjectOutputStream
 * 接收 ok BufferedReader
 */
public class client {
    public static void main(String[] args) {
        String host="127.0.0.1";
        int port = 8989;

        try (Socket socket = new Socket(host,port);
             Scanner sc = new Scanner(System.in);
             ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))){
            String s=null;
            List<Teacher> teacherList = new ArrayList<>();
            System.out.println("请输入信息：");
            while (!(s=sc.nextLine()).equalsIgnoreCase("quit")){
                String[] teacher = s.split("-");
                int age = Integer.parseInt(teacher[1]);
                double salary = Double.parseDouble(teacher[2]);
                Teacher teacher1 = new Teacher(teacher[0],age,salary);
                teacherList.add(teacher1);
            }
            System.out.println("输入的所有学生："+teacherList);
            out.writeObject(teacherList);
            System.out.println("客户端发送数据完成");
            String s1 = in.readLine();
            System.out.println("客户端收到服务器完成响应信息为："+s1);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * 搭建TCP服务器，端口8002
 * a.接收客户端发送的所有老师对象，遍历输出，并将老师信息全部写入
 * 本地文件 src/t.txt
 * b.写入完成后，返回给客户端一个信息: "ok"
 * c.最后关闭服务器
 *
 *
 * 接收老师对象 遍历输出 （所以接收的是老师的集合） ObjectInputStream
 * 写入文档 BufferedWriter
 * 给客户端返回一个信息”ok“  printWriter
 */
public class server {
    public static void main(String[] args) {
        int port = 8989;
        String url = "src/com/kim/work12/work/Teacher/t.txt";
        {
            try (ServerSocket serverSocket = new ServerSocket(port);
                 Socket socket =serverSocket.accept();
                 ObjectInputStream in = new ObjectInputStream(socket.getInputStream());
                 BufferedWriter outfile = new BufferedWriter(new FileWriter(url));
                 PrintWriter out = new PrintWriter(socket.getOutputStream())){
                System.out.println("client连接成功"+socket);
                List<Teacher> teacherList = (List<Teacher>) in.readObject();
                for (Teacher t :teacherList){
                    System.out.println("将 " +t+" 加入到文档");
                    outfile.write(String.valueOf(t));
                }
                System.out.println("保存完成！");
                out.println("ok");
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
}
```

还有抛出异常的一种，可读性好，但是需要手动关闭流

```
4.多线程 使用线程池可以更高效的管理线程资源，避免创建过多的线程，从而提高性能和稳定性
  注意：PrintStream字节输出 PrintStream字符输出 写入时自动刷新( ,true)
  try() java7之后 （）中的数据实现 AutoCloseable 接口,会自动关闭 不需要.close()
  "quit".equalsIgnoreCase(inputLine)//比较相等 不区分大小写差异
```

![image-20240904163518677](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240904163518677.png)



