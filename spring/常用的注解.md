因为摒弃了xml文件配置的方式，`全注解驱动`

##### 1.组件注册

`Configuration` `@SpringBootConfiguration`告诉spring是一个配置类

配置类是 Spring 应用程序上下文中的一个中心配置点，【定义 Bean 和其他应用程序配置。】

@Bean只能用于方法

@Component可以直接在实体类里面让他变成一个组件

 `@Controller`

@`ComponentScan` `@Service`

通过注册组件，spring可以自动注入组件之间的依赖。可以简化对象的创建和管理。

@Autowired在Springboot前就有

作用

```
1.spring可以注入组件之间的依赖，比如接口和实现类
2.spring会管理组件的生命周期
3.依赖注入机制可以减少彼此之间的耦合，提高代码的可维护性和测试性。
第三点解释：
3.1减少耦合：实例化创建对象，以下面的例子来说，controller和service就耦合性高了。
3.2测试更方便：比如mock
  @Mock
    private GreetingService greetingService;

    @InjectMocks
    private GreetingController greetingController;
假如没有这个的话，就不能直接使用模拟对象来注入
```



```java
@Component：通用的组件注解，适用于任何Spring管理的组件。
@Service：用于标识服务层的组件。
@Repository：用于标识数据访问层的组件，通常与数据库交互。
@Controller：用于标识Web控制器，处理HTTP请求。
@RestController：特殊的控制器注解，相当于@Controller和@ResponseBody的组合，处理RESTful Web服务的请求。
```

> 一种架构风格：设计原则和约束 
>
> RESTful Web 服务允许客户端通过 HTTP 协议与服务器进行交互，并通常使用标准的 HTTP 方法来操作资源 
>
> **特征：**
>
> - 每个资源（基本实体，对象、服务、文档…）唯一的URI标识。例如`/users/123`表示用户ID为123的资源
> - 统一接口：接口通常包括标准的Http方法（GET、POST、PUT、DELETE）来操作资源。
> - **表述格式**: 资源的表述可以是 JSON、XML、HTML 等，客户端和服务器通过这种格式进行数据交换。
> - **无状态**: 每个请求都是独立的，服务器不会存储客户端的状态。每个请求都应该包含所有处理该请求所需的信息。更容易扩展和负载均衡。
>
> //获取用户信息
>
> ```http
> GET /users/123  
> ```
>
> //该请求将获取用户 ID 为 123 的信息，通常返回 JSON 格式的数据，例如：
>
> ```json
> {
>     "id": 123,
>     "name": "John Doe",
>     "email": "john.doe@example.com"
> }
> ```
>
> //创建新用户
>
> ```http
> POST /users
> Content-Type: application/json
> 
> {
>     "name": "Jane Smith",
>     "email": "jane.smith@example.com"
> }
> ```
>
> 该请求将在服务器上创建一个新用户，并返回新用户的详细信息
>
> //更新用户信息、
>
> ```http
> PUT /users/123
> Content-Type: application/json
> 
> {
>     "name": "Johnathan Doe",
>     "email": "johnathan.doe@example.com"
> }
> ```
>
> 该请求将更新用户 ID 为 123 的信息。
>
> //删除用户
>
> ```http
> DELETE /users/123
> ```
>
> 该请求将删除用户 ID 为 123 的用户

###### 1.1ioc控制反转

传统对象是在对象内部自己控制，现在是一个ioc容器里放着一个个bean（组件或者对象）,通过容器来控制对象，控制权反转了。

例子

```java
不用ioc的
public class GreetingController {
    private GreetingService greetingService = new GreetingService();

    @GetMapping("/greet")
    public String greet() {
        return greetingService.greet();
    }
}
用ioc的
public class GreetingController {
  	@Autowired
    private GreetingService greetingService  //这里的GreetingService是接口
    @GetMapping("/greet")
    public String greet() {
        return greetingService.greet();
    }
}
```

这里就是Spring框架检查到@Autowired，直接把GreetingService的实现类的实例对象注入到greetingService上。



##### 2.条件注解

即如果这个条件成立，就触发行为

常见的

ConditionalOnXXXX

`ConditionalOnClass()`存在这个类就触发

`ConditionalMissClass()`不存在这个类就触发

`ConditonalOnBean()`

##### 3.属性绑定

```
@ConfigurationProperties(prefix = "cat")
@任何组件注册
```

 或者在要属性绑定的类只写 `@ConfigurationProperties(prefix = "cat")`,在启动类或者配置类上写一个

`EnableConfigrationProperties(Cat.class)`这个的意思就是自动注册组件