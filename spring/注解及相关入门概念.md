## **MYSQL**

`D:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld.exe` 是 MySQL 服务器的可执行文件路径。

`--defaults-file="D:\ProgramData\MySQL\MySQL Server 8.0\my.ini"` 指定了 MySQL 的配置文件路径。

**发动机**

![image-20240823220847018](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240823220847018.png)

**设置手册**

![image-20240823220902878](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20240823220902878.png)

## **Mapper**

指的是一个将数据从一个格式转换为另一个格式的组件。

**数据传输对象（DTO）**: 在某些情况下，Mapper 用于将数据库记录转换为数据传输对象，以便于在应用程序的不同层之间传递数据。

## **分布式系统**

### 例子：在线购物网站

想象一下你在使用一个大型的在线购物网站，比如亚马逊（Amazon）。这个网站可以被看作是一个分布式系统，因为它涉及到许多独立的计算机和服务，这些计算机和服务共同工作来提供完整的用户体验。下面是如何在这个网站中体现分布式系统的特性：

1. **多个服务器**:
   - **网页服务器**: 负责处理用户的网页请求，并将网页内容发送给用户。
   - **数据库服务器**: 存储用户的账户信息、订单记录和商品数据。这些服务器可能分布在不同的地理位置，以便更快地响应用户的请求。
   - **支付服务器**: 处理用户的支付信息和交易，确保支付过程的安全性。
2. **负载均衡**:
   - 当大量用户同时访问网站时，负载均衡器会将用户请求分发到多个网页服务器上，以确保没有一台服务器过载，从而提高网站的响应速度和稳定性。
3. **数据冗余和备份**:
   - 为了防止数据丢失，数据在多个数据库服务器上进行备份。如果一个数据库服务器出现故障，其他服务器可以继续提供服务，确保系统的可靠性。
4. **服务解耦**:
   - 网站的功能被拆分成多个独立的服务，比如用户管理、商品推荐、订单处理等。每个服务可以单独进行开发和维护，并可以独立扩展以满足需求的增长。
5. **异地部署**:
   - 一些关键服务可能部署在不同的地理位置，以便提高全球用户的访问速度。例如，北美的用户可能连接到北美的数据中心，而亚洲的用户则连接到亚洲的数据中心。

## `Serializable`接口

`Serializable`接口是Java编程语言中的一个标记接口（marker interface），用于指示一个对象的状态可以被序列化。序列化是将对象的状态转换为字节流的过程，方便将对象保存到文件、发送到网络、或者在不同的JVM之间传输。

具体来说，`Serializable`接口的作用如下：

1. **标记功能**：`Serializable`接口没有任何方法，它的唯一作用是标记一个类的对象可以被序列化和反序列化（即从字节流恢复到对象）。在Java中，标记接口用来提供额外的行为或特性，尽管接口本身不定义方法。
2. **持久化对象**：实现了`Serializable`接口的类可以通过Java的对象流（`ObjectOutputStream`）进行序列化。序列化后的字节流可以保存到文件中或者通过网络传输。
3. **反序列化**：在需要恢复对象时，可以使用`ObjectInputStream`来将字节流反序列化为对象。这个过程将字节流转换回对象状态，允许你恢复之前保存的对象。
4. **`serialVersionUID`**：为了确保反序列化时的兼容性，建议类中定义一个名为`serialVersionUID`的静态字段。这是一个唯一标识符，用于验证序列化和反序列化过程中类的版本是否匹配。如果类的版本发生变化，`serialVersionUID`可以帮助避免反序列化时的问题。

```java
import java.io.*;

public class Example implements Serializable {
    private static final long serialVersionUID = 1L;//推荐定义
    /*用于验证序列化和反序列化过程中类的版本是否匹配。如果类的版本发生变化，serialVersionUID可以帮助避免反序列化时的问题*/

    private String name;
    private transient int age;//transient 字段不会被序列化
    //序列化就是将对象的状态转换为字节流的过程，方便将对象保存到文件，发送到网络，或者在不同的JVM之间传输


    public Example(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Example{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public static void main(String[] args) {
        Example john = new Example("john", 30);
        //序列化
        try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("example.ser"))){
            out.writeObject(john);
        }catch (IOException e){
            e.printStackTrace();
        }

        try(ObjectInputStream in = new ObjectInputStream(new FileInputStream("example.ser"))){
            //反序列化 使用ObjectInputStream来将字节流反序列化为对象
            Example deserialized = (Example) in.readObject();
            System.out.println(deserialized);
        }catch (IOException| ClassNotFoundException e){
            e.printStackTrace();
        }
    }
}
```

## @PostMapping

 `@RequestMapping(method = RequestMethod.POST)`。的简化形式

处理POST请求：被注解标记的方法将会处理传入HTTPPOST请求，用于提交数据（如表单数据）到服务器。

**相关注解**

**`@RestController`**: 组合注解，它组合了 `@Controller` 和 `@ResponseBody`，返回的数据会直接写入 HTTP 响应体中。

> 类上有@RestController注解或@**Response**Body注解时：表示当前类下所有的方法返回值做为响应数据。
>
> - 方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器
>
> `@Controller` 注解的类主要用于传统的 MVC 模式，处理请求并返回视图，而 `@RestController` 结合了 `@Controller` 和 `@ResponseBody`，主要用于处理 RESTful API 请求，直接返回数据而非视图

**`@RequestMapping("/api")`**: 定义了这个控制器处理的基础路径。

**`@PostMapping("/submit")`**: 指定这个方法处理 `/api/submit` 的 POST 请求。

**`@RequestBody`**: 自动将请求体中的 JSON 数据转换为 `MyRequestData` 对象(实体类对象)。

> JSON中的key和实体类中的属性名保持一致

//**`handlePostRequest`**: 方法接受一个 `MyRequestData` 对象作为参数，并处理 POST 请求的数据。

SpringBoot环境中，将原始的API进行了分装，接收参数不用在方法的形参中声明HttpServletRequest 对象，然后通过对象来获取request.getParameter("参数名")；只需要，使参数名与形参变量名相同，定义同名的形参即可接收参数。若方法形参名与请求形参名称不一致，使用@RequestParam注解完成映射（@RequestParam(“name”) String username）

> 注意数组集合参数传递  
>
> 日期参数(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime updateTime)
>
> 路径参数  @RequestMapping("/path/{id}") (@PathVariable Integer id)

**响应**

上面说@**Response**Body与Controller组合了

关于统一响应结果，我们定义一个实体类Result来统一返回结果，在方法后return Result.success(list)

**IOC&DI**  控制反转(Invension Of Control)&依赖注入(Dependency Injection)

> 对象的控制权由程序员主动创建转移到容器（由容器创建、管理的对象）。就是不需new对象，改变service层的不需要再改变Controller
>
> 依赖注入就是资源，程序运行时需要某个资源，此时容器就为其提供这个资源。

**IOC容器中创建、管理的对象，称之为：bean对象**

任务：完成Controller层、Service层、Dao层的代码**解耦**

1. 删除Controller层、Service层中new对象的代码

2. Service层及Dao层的实现类，交给IOC容器管理   

   > 使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理

3. 为Controller及Service注入运行时依赖的对象

   > 使用Spring提供的注解：@Autowired (自动配置)，就可以实现程序运行时IOC容器自动注入需要的依赖对象

Spring框架为了更好的标识bean对象到底归属哪一层，提供了@Component的衍生注解：

- @Controller    （标注在控制层类上）
- @Service          （标注在业务层类上）
- @Repository    （标注在数据访问层类上）

四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描（再SpringBoot启动类上注解，但不推荐，我们只需要把它们都放在一个包（与SpringBootReqResApplication同包）下）我们定义的bean就会被自动扫描到

**DI** 在IOC容器中，存在多个相同类型的bean对象（EmpServiceA EmpServiceB）程序会报错

- @Primary    默认  @Primary \n@Service  当bean生效 IOC使用当前bean对象进行注入

- @Qualifier  指定当前要注入的bean对象。 

  > 在@Qualifier的value属性中，指定注入的bean的名称 @Qualifier(“empServiceA”) 默认的bean名称是类名首字母小写
  >
  > 注意：不能单独使用，必须配合@Autowired使用（这个在Controller中的@Autowired后）

- @Resource

  > 是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。
  >
  >  @Resource(name = "empServiceA")不需要@Autowired

**面试题** ： @Autowird 与 @Resource的区别

- @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解
- @Autowired 默认是按照类型注入，而@Resource是按照名称注入

> **`@Autowired`**：默认按类型注入，如果找到多个匹配的 Bean，需要通过 `@Qualifier` 进一步指定具体的 Bean。
>
> **`@Resource`**：默认按名称注入，可以通过 `name` 属性指定具体的 Bean 名称。如果按名称找不到 Bean，可能会尝试按类型注入。