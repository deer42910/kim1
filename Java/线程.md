#### 基本的一些概念和使用

> 关于床架线程的两种方式
>
> `Thread` 是一个类，你只能继承它；`Runnable` 是一个接口(函数式接口，只有一个方法run()，你可以实现它并与其他类继承结合使用。使用 `Runnable` 更灵活，允许你扩展其他类。
>
> `Thread` 类需要你每次都重写 `run()` 方法，而 `Runnable` 接口只需要你实现一次 `run()` 方法，然后将该实现传递给 `Thread` 对象。使用 `Runnable` 可以让你更灵活地复用同一个任务逻辑。

```java
public class ThreadDemo {
    // 线程是进程底下的，一个进程至少要有一个线程，可以多线程，比如一个杀毒软件是一个进程，他可以同时进行垃圾扫描和病毒查杀，就是2个线程


    //java虚拟机（JVM）是多线程，可以在运行程序的时候进行gc垃圾清除，使用finalize方法，具体在50题的那个文档里面写了关于finalize


    //并发：就是在一个时间段多个线程同时进行，其实就是cpu左右横跳分配调度权
    //并行：同一时刻多个线程同时进行，这时是一个进程用一个cpu。多核cpu就能实现
    // 我们这里学并发

    //调度方式：时间片轮转和抢占式
    //java虚拟机是抢占式

    //当main线程里start了才是为新的线程t创建了一个方法栈
    //main线程的启动过程： 1️⃣先启动JVM 2️⃣类加载 3️⃣创建并启动线程main
    //无论单还是双，都要线程全部结束JVM才会结束
    public static void main(String[] args) {
        //一般都是用匿名线程类，里面是名字,只有匿名对象类可以这样
        //完整的是init(null, null, "Thread-" + nextThreadNum(), 0);
        /*参数解读：
        *第一个是线程组，如果是null,则加入当前线程所在的线程组；
        *第二个是：指定线程的Runnable对象，即线程执行的任务。如果为null，则
        线程本身不执行任何任务，通常用于继承Thread类并覆盖其run()方法的情况。
        *第三个是 线程的默认名称 "Thread-" + nextThreadNum()  第一个子线程...
        *第四个是指定线程的栈大小，0则使用平台的默认栈大小，一般不设置
        * */
        Thread t =new Thread(null,null,"demo1111",0){
            public void run(){
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //这里不能用throw抛出interrupt(中断)异常的原因是：run()方法后面不允许抛出任何他checked(受检)异常，因此所有checkedexceptions必须在`run`方法中处理，通常使用"try-catch"语句块，线程的运行过程是由JVM管理的，`run`方法中抛出异常，线程会因为未处理的异常而异常终止，
                在 Java 中，Runnable 接口的 run 方法没有声明抛出异常，因此在实现 Runnable 的 run 方法时，你不能直接抛出受检异常。你只能捕获异常并在方法内部处理它，不能将异常抛出给调用线程。
                //但线程是相互独立的，线程 A 的异常不会影响线程 B 的执行。即使线程 A 因为未处理的异常而终止，线程 B 和主线程会继续运行。    
            }

        };
        /*方法
        * init方法，这个在Thread类里面的是private所以不可以调用，我们可以像下面我们定义的MyThread的构造方法来定义名字初始化,如果不传，他默认的名字是你的类名
        * getName() 拿到线程的名字
        * Thread.currentThread() 获取到【执行当前方法的】对象，常配合getName使用
        * */
        System.out.println(t.getName());
        System.out.println(Thread.currentThread().getName());
        //这边的t.start虽然在上面调用，但是老是最后输出，因为线程的调用是不确定的
        t.start();
        MyThread myThread =new MyThread();
        myThread.start();
        System.out.println(myThread.getName());
        /*
        * 使用实例对象调用方法
        *setName
        * */
        System.out.println("______________________");
        /*第二种创建线程类对象的方法，Runnable接口
        * 其实Thread类里面run就是实现这个接口的。
        * 因为java不支持多继承，所以通过实现这个接口能够更好的拓展，不过就无法使用Thread里面的类了
        * 同时支持匿名写，其实写外面也一样，反正只改写了run方法
        * 然后还是要用Thread的构造方法来创建，就是上面的init里面的target*/
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("runnable已启动");
            }
        };
        Thread thread = new Thread(runnable);
        System.out.println("通过runnable创建的线程默认名是："+thread.getName());

        System.out.println("+++++++++++++++++++++++++++");
        //优先级：priority 1-10级，默认是5级 。可以set和get  简单不讲


        //线程组
        /*
        * 首先就是还是上面那个init方法里面的第一个指定的group，只能在初始化的时候指定，其他时候都无法设置
        * 如果没有指定，就是所在线程默认的线程组
        * getThreadGroup()
        * 这些包括上面的之所以可以直接打印是因为在源码里面重写了toString
        * enumerate(Thread[] list)方法,即把所有活动的线程存进去
        * list()  输出当前的组的所有线程
        * activeCount()  当前组里存活的线程个数
        * */
        Thread thread4 = new Thread(runnable);
        System.out.println(thread4.getThreadGroup());
        ThreadGroup group = thread4.getThreadGroup();
        group.list();
        group.activeCount();
        System.out.println("______________________");

        //线程的状态， getState
        /*状态
      new新建   Runnable可运行    waiting无限等待     timedwaiting 阻塞等待
      blocked锁阻塞   dead    Timed Waiting计时等待  Teminated被终止
        * */
    }
}

class MyThread extends Thread{
    public MyThread(String name){
        super(name);
    }
    public MyThread(){

    }
    public void run(){
        System.out.println("run:MyThread");
    }
}


```

#### 同步

> 解决线程安全 多个线程同时执行写操作

```java
public class 同步 {
    //3种方法 1️⃣同步代码块[不一定是在runable的run重写里面的，其他的方法也行]
    class myrun implements Runnable {
        @Override
        public void run() {
            //这个括号里面可以是任何对象，但是要同一个，而且要同步的线程都是用这个myrun来创建的
            //⚠️一般在这个对象里面有像flag的值，根据你的线程个数自己设置就行了
            Object mutex = new Object();
            synchronized (mutex) {

            }
        }
    }

    public static void main(String[] args) {

    }
}

class Printer {
    //2️⃣同步方法  public [static] synchronized 返回值类型 同步方法()，【可以认为就是把一整个方法放到同步代码块里面】
    //当方法不是static时，他的上锁的对象就是this，也就是调用这个方法的对象.对于第一种方法想这样用就传一个this就行
    //当方法是static是，上锁的就是字节码对象，反射那里我写了关于字节码的 就是 Printer.Class
    public static synchronized void print1() {
        //xxxxxxxxxxx
    }


    /*2个和多个的区别：while和if的使用
    3个线程轮流执行的那个包子案例感觉没啥讲，就注意那个while 不能用if替代
    * 举个例子：比如现在已经有了两个包子，然后第一个消费者消费完了把flag改成了2，这时候唤醒所有，
    * 然后生产者被唤醒，这时候flag依然不等于0,如果是if就不会再判断了，直接往下又生产了，那么顺序就不满足需求说的轮流
    如果是while则会再判断一次。

    2个的那个，因为就2个互相叫醒，if就够了。
    * */

}



```

#### 守护线程（后台线程）

> ```java
> /*前台线程（用户线程）会阻止 JVM 退出，直到它们完成。而后台线程（守护线程）则不会阻止 JVM 退出，JVM 会在所有前台线程结束后终止后台线程。
>  JVM像急躁的女人 男神不让走 添狗随便你（你男神我就走）        
>  男神 前台(用户进程) JVM的添狗 守护线程*/
> // 设置 th2 为守护线程
> t2.setDaemon(true);  //守护进程 前台线程结束，JVM就退出，  若不设置为守护线程 也就是前台线程 jvm不能结束 运行完才结束
> ```

```java
public class 守护线程案例 {
    /**
     * 前台线程和后台线程（守护）
     * 就是JVM根本不吊后台启动与否，只有前台全部关闭JVM才会关闭，懒得理守护进程的死活。
     * 经常像那些清理的是守护
    * */
    /*案例
    创建子线程1:Thread子类 + 匿名内部类 从1循环输出到30，每次输出后停顿100ms
    创建子线程2: Runnable实现类 + 匿名内部类 从100循环输出到50，每次输出后停顿200ms
    运行测试 默认情况下，观察两个线程运行时效果 将线程2设置为守护线程，观察运行效果

    设置守护线程 setDaemon  这个值在Thread源码里面 private设置了false
    daemon | BrE ˈdiːmən, AmE ˈdim(ə)n  n.后台运行程序
    * */
    public static void main(String[] args) {
        Thread1 thread1 = new Thread1();
        Thread thread11 = new Thread("Thread-1"){
            public void run(){
                //和下面一样懒得写
            }
        };
        //线程2用内部类这里写
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i =100; i > 49; i--) {
                    System.out.println(i);
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        //会发现，如果是后台，jvm压根不吊他有没有运行完，直接拉闸
        thread2.setDaemon(true);
        thread1.start();
        thread2.start();

    }
}
//线程1
class Thread1 extends Thread {
    @Override
    public void run() {
        for (int i = 1; i < 31; i++) {
            System.out.println(i);
            try {
                sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

join方法

> ```java
> t1.join();//没传入参数 到达80 暂停线程2（线程1插入） 一直到运行线程1 直到1结束 2才开始
> t1.join(50);  //线程2暂停50秒 只输出线程1
> /*状态不同 没参数从RUNNABLE->WAITING   
> 有参数（与sleep相同）从RUNNABLE->TIMED_WAITING*/
> ```

```java
import sun.awt.windows.ThemeReader;
                            
public class join小案例 {
    /* join() 等到死
    join(time/ms)指定等待
    注意，这里是让别的线程join来，让自己等待
    *  创建子线程1，每隔10ms输出1-40
2. 创建子线程2，每隔10ms输出100-70
3. 当线程2输出到80时，执行th1.join()或th1.join(50) 4. 观察两种join的运行结果
完成上述功能后，再额外实现:主线程每隔7ms输出子线程2状态*/
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(new Runnable(){

            @Override
            public void run() {
                for (int i=1;i<=40;i++){
                    System.out.println(i);
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        Thread thread2 = new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i=100;i>69;i--){
                    System.out.println(i);
                    if (i==80){
                        try {
                            thread1.join(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        thread1.start();
        thread2.start();
        while (thread2.isAlive()){
            System.out.println(thread2.getState());
            Thread.sleep(7);
        }

    }

}

```

#### 线程池

线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

> 因为并发的线程很多的话，每一个线程执行很短的时间但其创建和销毁线程也需要时间。

![image-20240822191926442](D:\a_briup_learn\Java\线程.assets\image-20240822191926442.png)

```java
方法：public static ExecutorService newFixedThreadPool(int nThreads) 返回线程池对象 （创建有界线程池，线程个数的最大数量）
*创建：ExecutorService threadpool=Executors.newFixedThreadPool(int
nThreads)  
线程池对象方法：piblic Future<?> submit(Runnable task) Future接口：记录线程任务执行哇安保后产生的结果 （）获取线程池中的某一线程对象并执行
* 使用:service.submit(r); r是一个runnable对象
```

> concurrent并发  线程池接口 java.util.concurrent.ExeuctorService
>
> Executor执行者 



好的，我会给你一些不同方面的 Java 线程基础问题。试试看你能回答多少！

1. **线程创建**
   如何在 Java 中创建一个线程？请列举两种常见的方法。
2. **线程状态**
   线程的生命周期包括哪些状态？请简要描述每个状态的含义。
3. **线程同步**
   什么是线程同步？为什么需要它？请给出一个简单的例子说明如何使用 `synchronized` 关键字来实现线程同步。
4. **线程优先级**
   如何设置线程的优先级？线程优先级对线程的执行有什么影响？
5. **线程池**
   什么是线程池？Java 中的 `ExecutorService` 是如何帮助管理线程的？
6. **线程中断**
   线程中断是什么？如何优雅地中断一个正在运行的线程？
7. **`Runnable` 和 `Callable`**
   `Runnable` 和 `Callable` 接口有什么不同？什么时候应该使用 `Callable` 而不是 `Runnable`？
8. **`join` 方法**
   `Thread.join()` 方法的作用是什么？在什么情况下你会使用它？
9. **线程的 `sleep` 方法**
   `Thread.sleep()` 方法的作用是什么？它有什么限制？
10. **`volatile` 关键字**
    `volatile` 关键字在 Java 中有什么作用？它如何影响线程之间的可见性？

可以选择一个或多个问题来回答，或者如果你需要解释某个概念，请告诉我！



1.常见的方法 一个是继承Thread类  一个是实现Runnable接口  

继承创建对象重写方法   接口时用Thread的构造器实现或内部类实现

2.状态  

new创建了没有使用start   

Runnable运行状态

Blocked用锁对象锁住线程的持有，就进入

waiting 无限等待 等待另一个线程执行唤醒动作，自己不能唤醒自己   notify()或notifyAll()唤醒动作

timed-waiting 到时间自动唤醒

Teminate(被终止) run方法正常退出 或没有捕获到异常终止run方法而死亡dead

3.线程同步是，一个时间段有多个线程要进行，线程安全问题，一个线程已经执行了该操作而另一个线程未知也执行了改操作，导致重复。

synchronized 同步代码块：准备锁对象【多个线程】  同步方法：使用Synchronized修饰的方法有普通成员方法和静态成员方法，普通默认锁对象this,静态锁对象是当前类的字节码对象

4.setPtiority(int newPriority)  优先级越高，抢占CPU使用权的概率越高，但不保证严格的执行顺序，线程调度由JVM和操作系统决定。

5.有多条线程，我们规定几个线程在线程池中，其中的线程可以反复使用，省去了频繁创建线程对象的操作

6.程序终端，t.setDaemon(true); 将线程设置为守护线程，jvm可以结束运行

8.jion将调用者的线程插入到正在运行的线程中，使正在运行的线程暂时停止或停止直到调用者执行完成。排队上厕所，我很着急插进去先解决

9.sleep是让线程暂时停止执行，暂停规定的时间后又开始执行

### 1. **线程创建**

在 Java 中创建线程有两种常见的方法：

- 继承 `Thread` 类

  ：创建一个类继承 

  ```
  Thread
  ```

  ，重写其 

  ```
  run()
  ```

   方法，然后创建该类的实例并调用 

  ```
  start()
  ```

   方法。

  ```
  java复制代码public class MyThread extends Thread {
      @Override
      public void run() {
          System.out.println("Thread is running.");
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          MyThread thread = new MyThread();
          thread.start();
      }
  }
  ```

- 实现 `Runnable` 接口

  ：创建一个类实现 

  ```
  Runnable
  ```

   接口，重写其 

  ```
  run()
  ```

   方法，然后将该类的实例传递给 

  ```
  Thread
  ```

   构造函数并调用 

  ```
  start()
  ```

   方法。

  ```
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          System.out.println("Runnable is running.");
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          Thread thread = new Thread(new MyRunnable());
          thread.start();
      }
  }
  ```

### 2. **线程状态**

- **New**：线程已创建，但尚未启动。
- **Runnable**：线程已启动并正在运行或准备运行（包括在操作系统中等待运行的状态）。
- **Blocked**：线程因试图访问被其他线程持有的锁而被阻塞。
- **Waiting**：线程在等待另一个线程执行特定操作（如 `wait()` 方法）。
- **Timed-Waiting**：线程在等待一个特定的时间段（如 `sleep()` 方法）。
- **Terminated**：线程已完成执行或因异常终止。

### 3. **线程同步**

线程同步是确保多个线程安全地访问共享资源的机制，防止竞态条件和数据不一致。

- 同步代码块

  ```
  public class Counter {
      private int count = 0;
  
      public void increment() {
          synchronized(this) {
              count++;
          }
      }
  }
  ```
  
- 同步方法：可以使用 

  ```
  synchronized
  ```
  
   修饰方法，确保整个方法的线程安全。

  ```
  public synchronized void increment() {
      count++;
  }
  ```

### 4. **线程优先级**

- 设置优先级：使用 

  ```
  Thread.setPriority(int newPriority)
  ```
  
   设置线程优先级。优先级范围从 1 到 10。

  ```
  Thread thread = new Thread();
  thread.setPriority(Thread.MAX_PRIORITY); // 设置为最高优先级
  ```
  
- **优先级影响**：线程优先级可能影响线程调度，但不保证严格的执行顺序。线程调度策略由 JVM 和操作系统决定。

### 5. **线程池**

- **线程池**：管理一组线程，重复利用这些线程来执行任务，避免频繁创建和销毁线程的开销。

- `ExecutorService`：提供线程池的实现，支持任务提交、线程池管理等。

  ```
  ExecutorService executor = Executors.newFixedThreadPool(10);
  executor.submit(() -> System.out.println("Task is running."));
  executor.shutdown();
  ```

### 6. **线程中断**

- 线程中断：用于请求线程停止执行。线程可以通过检查中断状态和响应中断来优雅地终止。

  ```
public class MyRunnable implements Runnable {
      @Override
      public void run() {
          while (!Thread.currentThread().isInterrupted()) {
              // 执行任务
          }
      }
  }
  ```
  
  - 使用 `Thread.interrupt()` 方法请求中断。
- 在线程内部使用 `Thread.isInterrupted()` 检查中断状态。

### 7. **`Runnable` 和 `Callable`**

- **`Runnable`**：没有返回值，也不能抛出检查型异常。

- `Callable`：可以返回结果和抛出检查型异常。

  ```
  Callable<Integer> task = () -> {
      return 123;
  };
  Future<Integer> future = executorService.submit(task);
  Integer result = future.get(); // 获取结果
  ```

### 8. **`join` 方法**

- 作用：使调用线程等待直到被调用的线程执行完成。

  ```
  Thread thread = new Thread(() -> {
      // 执行任务
  });
  thread.start();
  thread.join(); // 主线程等待 thread 执行完成
  ```
  
- **使用场景**：用于确保主线程在所有子线程完成之后再继续执行，例如等待多个线程的任务完成后再进行汇总。

### 9. **线程的 `sleep` 方法**

- 作用：使当前线程暂停指定的时间（毫秒）。

  ```
  Thread.sleep(1000); // 暂停 1 秒
  ```
  
- **限制**：`sleep()` 方法可能会被中断，暂停的时间不是绝对的，可能会因其他因素而有所变化。

### 10. **`volatile` 关键字**

- 作用：确保变量的修改对所有线程可见，避免 CPU 缓存的优化导致的可见性问题。

  ```
  private volatile boolean flag = false;
  ```
  
- **影响**：`volatile` 变量保证了线程读取的是最新的值，但它不提供原子性或同步保证。
