# 第三章-位运算

## 操作符

#### %取余

余数的符号看被除数

> 被除数/除数=商...余数
>
> 除数×商+余数=被除数
>
> 13%5=3 -13%5=-3 -13%-5=-3

### 除法运算

Java中双目运算符得计算结果与操作数类型相同:int与int计算结果为int float与float计算结果为float

###### 面试题

```
int total = 100;
int num = 40;
System.out.println("商品的单价是" + total / num + "元。");
//商品的单价是2元
```

方法一：将操作数类型转换为浮点类型

```
int total = 100;
int num = 40;
double totalDouble = total;
System.out.println("商品的单价是" + totalDouble / num + "元。");
//商品的单价是2.5元
```

方法二：直接使用强转，将操作数转换为浮点型

```
int total = 100;
int num = 40;
System.out.println("商品的单价是" +(double) total / num + "元。");
//商品的单价是2.5元
```

### 浮点类型的除法运算的特殊处理

即浮点数零做除数得问题

```
/**
 * 浮点类型的除法运算的特殊处理
 * 1、在程序中，（整形0）是不能做除数的，编译可以通过，但运行报错：ArithmeticException算术运算错误
 * 2、在Java中，（浮点型的0）是可以做除数的
 * 若计算结果为正 Infinity 正无穷大  结果为负 -Infinity 负无穷大
 * 0.0可以理解为，无限趋向与0，但是大于0的数
 * 3、非数 NAN Not a number (0.0/0.0)
 * 4、正负无穷大和非数的等值问题
 * Infinity与Infinity是相等的
 * -Infinity与-Infinity是相等的
 * NAN与NAN是不相等的
 * @author ASUS
 */
public class Demo1 {
    //设计一个方法，用于判断这个浮点数是否是非数
    static boolean isNAN(float value){
        //当传入的value是NAN,返回true
        //否则false
        return value!=value;
    }
    public static void main(String[] args) {
        int a =10;
        int b =0;
        //System.out.println(a/b);//by zero不能被除
        System.out.println(10/0.0);//Infinity  (正无穷大)
        System.out.println(-10/0.0);//-Infinity
        System.out.println(10/-0.0);//-Infinity
        System.out.println(0.0/0.0);//NAN
        System.out.println(0.0/2);//0.0

        System.out.println(10/0.0 == 10/0.0); //true
        System.out.println(10/-0.0 == 10/-0.0); //true
        System.out.println(0.0/0.0 ==0.0/0.0);//false
        double c = 0.0/0.0;
        //JavaAPI中包含了Float与Double判断是否为NAN的方法
        if (Float.isNaN((float) c)){
            System.out.println("是非数"); //是非数
        }else {
            System.out.println("不是非数");
        }
    }
}
```

Infinity大于程序中任意可取到得值 -Infinity小于程序中任意可取到得值

```
//取正⽆穷⼤值
double positiveInfinity = Double.POSITIVE_INFINITY;
System.out.println(positiveInfinity > Double.MAX_VALUE); // true
System.out.println(positiveInfinity > Long.MAX_VALUE); // true

//取负⽆穷⼤值
double negativeInfinity = Double.NEGATIVE_INFINITY;
System.out.println(negativeInfinity < Double.MIN_VALUE); // true
System.out.println(negativeInfinity < Long.MIN_VALUE); // true
```

#### 字符串相加

1、加法运算

2、字符串连接符

> 注意从左到右，逐步进行
>
> ```
> System.out.println("hello"+'a'+1);
> //helloa1
> System.out.println('a'+1+"hello");
> //97+1=98  98hello
> System.out.println("5+5="+5+5);
> //5+5=55
> System.out.println(5+5+"=5+5");
> //10=5+5
> ```

**易错点：表达式中有多个不同类型操作数，使⽤多个 + 连接，要注意每个 + 的运算性质。**

###### 面试题

```
double pencil=2.5;
double book=10.0;
System.out.println("商品总价是： "+pencil+book);
//商品总价是： 2.510.0
//按照顺序从左到右
//正确写法：
System.out.println("商品总价是： "+(pencil+book));
//商品总价是： 12.5
注意平时工作中// 1+2+"3"+4+5  3345
```

### 自增自减

只能用于变量，不能用与常量

1、单独使用，对变量进行自增自减，2种方法相同

2、作为表达式

```
 * ++、-—运算符
 * 1、变量前，符号后
 * a++，b--
 * 先使用变量的当前值，后引起自加或自减的值
 * 2、符号前，变量后
 * --a,--b
 * 直接自增或自减的值
```

> 注意：i=i++;i实际上没有发生变化

###### 面试题1

```
int x = 4;
int y = (x--) + (--x) + (x * 10);
System.out.println("x: " + x); // x: ?  4+2+20=26  x=2 y=26
System.out.println("y: " + y); // y: ?
```

###### 面试题2

```
public static void main(String[] args) { 
    byte b = 10; //八种数据类型只有boolean不能自增
    b++; 
    b = b + 1; 
    //问哪句会报错,为什么？ 
}
b=b+1;报错，b是byte型，=后是int型
```

扩展

分析字节码指令即可得出结论。使⽤ javap -c Xxxx.class 命令对字节码进⾏反编译，内容如下

> 关于i++和i--的区别我们可以通过分析字节码指令实现
>
> 所以准确来说， i = i++ 这样的命令运⾏完之后 i 的值没有变化，实际上是因为它“变过之后”⼜“变了回去”。

```
/**
 * i++和i--的区别我们可以通过分析字节码指令实现
 * 第一步，可以先对.class文化进行反编译
 * 反编译：javap工具  可以吧.class文件的十六进制得指令转换成带有助记符得字节码指令
 * @author ASUS
 */
public class Demo3 {
    public static void main(String[] args) {  //args也是局部变量0，第一个局部变量是i 第二个局部变量是j
0：args
1:   i
2：   j
        //分析字节码指令
        int i = 10;
        i=i++;//注意：i的值不变   10（自增过 后背抹掉回来）
        System.out.println(i);
        int j = 20;
        j=++j;  //21
        System.out.println(j);
       /* 字节码  字节码指令的分析 （java的所有）
       public static void main(java.lang.String[]);
        Code:
        0: bipush        10     把常量10堆入操作数栈栈顶
        2: istore_1             操作数栈栈顶位置的值赋值给给第[1]个局部变量int i
        3: iload_1              把局部变量的第[1]个值堆入操作数栈栈顶
        4: iinc          1, 1  第[1]个局部变量自增1
        7: istore_1            把操作数栈栈顶的值赋值给第[1]个局部变量
        8: getstatic     #2    调用静态指令sout()打印值的过程             // Field java/lang/System.out:Ljava/io/PrintStream;
        11: iload_1
        12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        15: bipush        20    把常量20堆入操作数栈栈顶
        17: istore_2            操作数栈栈顶位置的值赋值给给第[2]个局部变量int j
        18: iinc          2, 1  第[2]个局部变量自增1 ：21
        21: iload_2             把局部变量的第[2]个值（21）堆入操作数栈栈顶
        22: istore_2            把操作数栈栈顶的值赋值（21）给第[2]个局部变量
        23: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        26: iload_2
        27: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        30: return*/
    }
}
```

#### 反编译操作码

`iload`、`iinc` 和 `istore` 是用来处理整数类型数据的操作码

iload：将一个局部变量中的整数值加载到操作数栈上。

iinc：对一个局部变量中的整数值进行自增操作。这个操作会将局部变量表中指定索引的值增加一个常量。

istore：将操作数栈顶的整数值存储到局部变量表中的指定位置。

```
int x = 10;
x += 5;
```

```
iload 1     // 将局部变量表中索引为 1 的整数值（10）加载到操作数栈上
iinc 1 5    // 将局部变量表中索引为 1 的整数值增加 5（即将 10 改为 15）
istore 1    // 将操作数栈上的值（15）存储回局部变量表中索引为 1 的位置
```

### 赋值运算符

###### 面试题

```
//面试题
short s = 10;
//s = s + 5; //error
s += 5; // s = (short)(s+5);
System.out.println("s: " + s);
```

> 注意：+=、-=、*=、/= 等扩展的赋值运算符，隐含了强制类型转换！
>
> 本来s是short类型，不能与int型得计算

### 位运算符

1、注意使用简便算法 原码-->补码 取反加一 补码-->原码 取反加一

> 注意转化为补码计算，正数原码补码相同，负数原码取反加一；后又将补码返回为原码。
>
> 取反得到补码，需转化为原码
>
> 简化计算：&找相同的 |有的加起来 ^|-&  ~该数得相反数-1

```
//位运算：按比特位逐位计算
//每一个结果连接起来做为最终计算
int a = 5;     //               00000101
int b = -13;   //10001101  原码：11110011
System.out.println(a&b);  //00000001 正数补反原码相同 1
System.out.println(a|b); //补码11110111  反码11110110 原码10001001:-9
System.out.println(a^b); //11110110  11110101 10001010:-10
System.out.println(~a);  //相反数-1 得-6  5取反是补码11111010 11111001 10000110;-6
int c = 23;     //16+4+2+1
int d = 77;     //64+8+4+1
System.out.println(c&d);  //1:相同的：4+1 = 5
System.out.println(c|d);  //有1就是1：64+16+8+4+2+1=95
System.out.println(c^d);  //01011010 95-5=90
System.out.println(~c);  //23的相反数-23  -1  =-24
```

2、一个数 异或 另一个数 2次，结果是自己

```
//不借助第三个变量，完成两个数的交换
public static void swap2(int a,int b){
    System.out.println("交换前：a:"+a+",b="+b);
    //一个数 异或 另一个数两次，结果是自己
    a=a^b;
    b=a^b; //a^b^b==>a
    a=a^b;//a^b^a==>b
    System.out.println("交换后：a:"+a+",b="+b);
}
```

## 扩展练习？见作业

对某一位置置0或置1

> 置1  value|(1<<(n-1))
>
> 置0  value&~(1<<(n-1))

### 移位运算符

算术右移(>>):低位抛弃，高位补符号位的值

逻辑右移(>>>):低位抛弃，高位补0

左移(<<):高位抛弃，低位补0

> 每左移1位，等同于 值*2
>
> 数值左移n位(移动后将超出数值最高位)，等同 数值 << (n%当前值所属类型所占比特位) 1*2^n

```
System.out.println(5>>1);  //00000101 00000010 2  5/2=2
System.out.println(20>>2);  //20/4=5
System.out.println(5>>>1); //2
System.out.println(-5>>1); //10000101 补码11111011  移 补11111101 原10000011 -3

System.out.println(5<<1);  //00000101 移 00001010  10
System.out.println(5<<2);  //00010100  20
System.out.println(5<<3);  //00101000  40
System.out.println(-5<<1); //10000101  1 00001010 -10 -5*2^1=-10  
//设置一个IO流读取缓冲区大小位1024
int bufferSize=1<<10; //1*2^10=1024
System.out.println(bufferSize);
```

### 短路运算符

&& 与 ||

单符号的&、|与双符号&&、||

相同点：

1、运算逻辑相同 &同真为真，有假就假 | 有真就真，同假才假

不同点：

1、单符号可以和八大基本数据类型中的全部类型都能计算。 逻辑&|（双符号）只能针对于布尔类型以及布尔类型的表达式进行计算
2、逻辑&|（双符号）还叫做短路运算符，在有多个表达式或值连接的条件下，前面的已得出结果就不会计算后面的。短路并非都发生，只有第一个式子能得出最终结果才能导致短路。 &&：发现有一个假，后面不用算，为假 ||：发现有一个真，后面不用算，为真

###### 面试题

```
/*
 * 1、控制台输出的结果是什么？
 *
 * 2、如果把i++换成++i，则输出结果为？
 *
 * 3、在第二问的基础上，把第二个判断条件改为--j>=10，输出结果是什么？
 */
public static void main(String[] args) {
    int i=6;
    int j=10;
    if(i++>=7 && j--<=10){  //6>=7false   6++  短路
        System.out.println("hello"); //不执行
    }
    System.out.println(i);//7
    System.out.println(j);//10

    int a=6;
    int b=10;
    if(++a>=7 && b--<=10){  // 6++ 7=7true && 10=10true 10--=9
        System.out.println("hello"); //hello
    }
    System.out.println(a);//7
    System.out.println(b);//9

    int a1=6;
    int b1=10;
    if(++a1>=7 && --b1>=10){  // 6++ 7=7true && false
        System.out.println("hello"); //不输出
    }
    System.out.println(a);//7
    System.out.println(b);//9
}
```

### 三目运算符

> (a>b)?"a大于b":"a小于b"

```
Scanner sc = new Scanner(System.in);
        System.out.println("请输入学生成绩(0-100范围内)：");
        int scroe = sc.nextInt();
        String result = scroe > 100 || scroe < 0 ? "输入值不合法" :
        scroe >= 90?"优秀":
        scroe >= 80?"良好":
        scroe >= 70?"中等":
        scroe >= 60?"及格":"不及格";
        System.out.println("成绩为："+result);
```

### Switch注意

> 如果所有case中的某个条件满足了，不会刻意触发default的执行
>
> 若case都不满足，不论default的位置在头（else只能在结尾）或是尾部，才会执行 ：鞋在脑袋上，不犯法不推荐
>
> 非最后一个语句，不加break！不论其后的case是否满足都会执行。

```
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个模式值[0, 1, 2, 3]：");
int mode = sc.nextInt();
// 定义一个switch结构，对mode的值进行判断和处理
// 注意：所有的case只是声明一个分支起点，
// 程序会挑选符合要求的case分支作为起点，一直向下运行
//  （包括运行其他case中的语句），直到遇到break或执行完所有语句才会结束
switch (mode) {
    case 0:
        System.out.println("选择了默认模式！");
        break;
    case 1:
        System.out.println("选择了制热模式！");
        break;
    case 2:
        System.out.println("选择了制冷模式！");
        break;
    case 3:
        System.out.println("选择了抽湿模式！");
        break;
    // default：如果所有case中的某个条件满足了，不会刻意触发default的执行
    // 如果所有case声明的值都不满足条件，才会从default处开始执行。
    default:
        System.out.println("输入的数值不合法！");
        break;
}
```

### 奇数偶数判断

**n&1=1 奇数**

**n&1=0 偶数**

> ##### %2==0 偶数 %2==1奇数 但是-3%2=-1

```
if((n&1)==1){
    //输出奇数
}else {
    //输出偶数
}
```

```
if((n<<31>>31)==1){
    //输出奇数
}
```

> 注意：& | << >>的优先级极低
>
> &&的优先级高于||

程序设计思想 降低冗余，重复的代码尽量不写，找方法写一个就好

### 最大公约数 最小公倍数

36 10

> 36%10 = 3......6
>
> 10%6 = 1.....4 除数/余数
>
> 6%4 = 1.....2
>
> 4%2 = 2.....0
>
> 最大公约数2 最小公倍数180 36*10/2
>
> 辗转相除后得到余数为0的除数 两个数相乘除以最大公约数

### 随机数

```
/**
 * 固定公式：生成[min,max]随机数
 * (int)(Math.random()*(max-min+1))+min;
 *java.lang.Math,其中random()方法返回值：[0,1)
 *
 * 生成随机数的方法Math.random()
 * 借助一个Random对象生成一个伪随机数
 * 返回值为double,返回的是一个【0，1）区间范围内的浮点数集
 * 得到的返回值 ：0<=r<1
 *
 * 计算指定范围随机数的方法：
 * 1、通过乘法扩大取值范围
 * 2、通过加减法计算偏移量，调整开始位置和结束位置
 * 25-37
 * (int)r*(37-25+1)+25
 *
 * //(0-5)  0<=6r<6  每一项都乘以一个正数 将double强转为int 舍弃小数点后面的就会使范围成4
 */
```

```
int random = (int)(Math.random()*(5-(-5)+1))+(-5);
System.out.println(random);
```

#### 注意顺序

```
(int)(Math.random()*(max-min+1))+min  //最推荐 整形+整形
(int)(Math.random()*(max-min+1)+min)  //上两种都行 就是要先进行乘法运算  浮点型+浮点型
(int)Math.random()*(max-min+1)+min  //错误
```

### for执行循环的次数

100遍历打999 999-100+1=900

### for循环不只有int型

```
public static void main(String[] args) {
    //打印输出所有的大写英文字母（按顺序）
    // 26个  A:65 a:97
    for (int i=0;i<26;i++){
        System.out.print((char) (i+65)+"\t");
    }
    System.out.println();
    for (char c='A';c<='Z';c++){
        System.out.print(c+"\t");
    }
}
```

### 百十个

3位数

> 百位 a/100
>
> 十位 a/10%10
>
> 个位a%10

second=7331转化成时分秒

> minutes = 7331/60 % 60
>
>  多少个整分钟 122......11   122%60=2.....2 两小时2分钟11秒

函数：Math.pow(数字，次方)阶乘 Math.Max(x,y) x,y中较大的一个

![1722500142199](C:\Users\ASUS\Desktop\JD\图片\1722500142199.jpg)

1、类加载系统

查找加载class文件 读取文件中的信息 加载进JVM内存

2、运行时数据区间的所有的数据 int a=10; new Sanner()

3、执行引擎

interpreter字节码解释器

栈(Stack)：客栈（宾馆）、货栈

> 容量小、临时性、进出快
>
> 总结：栈负责保存体积小的，生命周期不太长（基本数据类型变量的值，局部变量）
>
> 栈在默认情况下容量只要1MB. 1024kB=1024*1024B
>
> 栈在Java运行过程中，与方法的执行有密切联系，栈中允许保存的数据全部都是跟方法有关的
>
> 规则[FILO(first in last out),先进后出，后进先出]
>
> 当每个方法被调用时的时候，JVM都会对虚拟机栈进行一次压栈，开辟的这一块栈空间称为”栈帧“
>
> 每个方法每次被调用的过程中，都拥有一个自己专用的存储空间，这个空间中保存的数据无法被其他方法访问。这个空间就是“栈帧”

栈帧： 1、局部变量表 注意：方法的局部变量在方法被调用了，执行期间，才会出现在内存中。在方法没有被调用的时候，局部变量实际上是不存在的。

局部变量表中包含

- 方法定义的参数

- 方法内部定义局部变量

  > 方法中的局部变量包括形式参数 如：String[] args 是第一个局部变量

2.操作数栈

> 用于完成一些算数运算

3.返回地址

4.动态地址

堆(Heap)：一大堆、人堆、垃圾堆

> 容量大
>
> 保存生命周期比较长的数据
>
> 具体功能：用来保存java程序运行期间的所有对象
>
> Java中创建的所有的对象（new）实际上都是在堆中开辟了空间，保存这个对象的数据。

#### 重载

方法调用的过程：就是形参给实参赋值的过程
