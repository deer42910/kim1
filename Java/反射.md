# 反射

```
双亲委托机制：类加载器收到类加载请求，他不会自己先去加载，而是把这个请求委托给父类的加载器去执行，若父类加载器还存在其父类加载器，则进一步向上委托，最终加载请求会到达顶层的启动类加载器BootstapClassLoader
-若顶层类加载器可以完成加载任务，则进行class文件类加载，加载成功后返回，若无法加载，就向下委托，此时子类加载器才会尝试加载，成功则返回，失败则继续向下委托，若所有的加载器都无法加载该类，则会抛出ClassNotFoundException。
```

类加载过程按需进行的，即在首次使用类时才会触发类的加载和初始化。

![image-20240905092552987](D:\a_briup_learn\Java\反射.assets\image-20240905092552987.png)



![1722500142199](D:\briup_study\JD\图片\1722500142199.jpg)



> 1.框架和库：Spring框架：使用反射来创建和管理Bean的生命周期，注入依赖，以及处理注解配置
>
> 2.动态代理
>
> AOP(面向切面编程)
>
> 3.单元测试
>
> 尤其是Junit，反射被用来访问私有字段和方法，以便测试内部实现。
>
> 4.对象序列化和反序列化
>
> 5.配置和插件系统

反射是允许对成员变量，成员方法和构造方法的信息进行编程访问（就像idea中的提示就是反射的作用）

**获取class文件的三种方式**

1. Class.forName(“全类名”)；  源代码阶段     java文件->.class文件 硬盘中真实存在的
2. 类名.class                                加载阶段        加载到内存中
3. 对象.getClass();                      运行阶段         内存中创建对象

> 字节文件对象：当.class文件加载到内存之后，JVM自动创建除来的对象。
>
> 类加载之后再方法区封装一个Class类

```java
package com.kim.reflact.classFile;
/**
 * @Author:kim
 * @Description: 获取class对象的三种方式
 * @DateTime: 2024/8/22 23:29
 **/
public class ClassFile {
    public static void main(String[] args) throws ClassNotFoundException {
        /*
         * 获取class对象的三种方式
         *   1.Class.format("全类名");
         *   2.类名.class
         *   3.对象.getClass()
         */

        //全类名： 包名+类名   .连接
        //最常用的
        Class<?> class1 = Class.forName("com.kim.reflact.classFile.Student");

        //一般更多的是参数进行传递（比如线程同步的静态同步方法）
        Class<Student> class2 = Student.class;

        //当我们已经有了这个类的对象时，才可以使用
        Student stu = new Student();
        Class<? extends Student> class3 = stu.getClass();

        System.out.println(class2 == class1);
        System.out.println(class2 == class3);
        System.out.println(class1 == class3);
    }
}
```

![7428ebfceb41f7c6789f38befc8bf1d7](D:\a_briup_learn\Java\反射.assets\7428ebfceb41f7c6789f38befc8bf1d7.png)

![image-20240823091832953](D:\a_briup_learn\Java\反射.assets\image-20240823091832953.png)

**Constructor**

> 某个类的构造函数.<init>

```java
package com.kim.reflact.constructor;

import com.kim.reflact.classFile.Student;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * @Author:kim
 * @Description: 利用反射获取构造方法 获取详细信息 
 public修饰符 com.kim.reflact.classFile.Student名字(java.lang.String,int)形参   还可以创建对象
 * @DateTime: 2024/8/22 23:54
 **/
public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        /*
          get表示获取
          Declared表示私有
          最后的s表示所有，复数形式
          如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用
         * | Constructor<?>[] getConstructors() | 获得所有的构造（只能public修饰） 
         * | Constructor<?>[] getDeclaredConstructors()| 获得所有的构造（包含private修饰）
         * | Constructor<T> getConstructor(Class<?>... parameterTypes)| 获取指定构造（只能public修饰）
         * | Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) | 获取指定构造（包含private修饰） 
         
          constructor6.newInstance("", );     instance实例  ()所要创建对象的参数 
         */
        Class<?> class1 = Class.forName("com.kim.reflact.classFile.Student");

        Constructor[] constructors1 = class1.getConstructors();
        for(Constructor c : constructors1) {
            System.out.println(c+":------"+c.getParameterTypes());
        }
        System.out.println("-----------------------------");
        Constructor[] constructors2 = class1.getDeclaredConstructors();
        for(Constructor c : constructors2) {
            System.out.println(c+":------"+c.getParameterTypes());
        }
        System.out.println("-----------------------");
        Constructor constructor3 = class1.getConstructor();
        System.out.println(constructor3);
        Constructor constructor4 = class1.getConstructor(String.class,int.class);
        System.out.println(constructor4);

        System.out.println("==========================");
        Constructor constructor5 = class1.getDeclaredConstructor(String.class,int.class);
        System.out.println(constructor5);

        System.out.println(constructor4==constructor5);//false每次获取构造方法对象的时候，都会新new一个

        Constructor constructor6 = class1.getDeclaredConstructor(int.class);

        //暴力反射：表示临时取消权限效验  accessible访问
        //它的主要作用是绕过 Java 的访问控制检查，从而允许对类的私有成员（字段、方法、构造方法等）进行访问。
        constructor6.setAccessible(true);
        Student student =(Student) constructor6.newInstance(23);//不能访问到私有 无法用这个构造器创建对象
        System.out.println(constructor6);
        System.out.println(student);//Student{name='null', age=23}
    }
}
```

**Field**

```java
package com.kim.reflact.field;
import java.lang.reflect.Field;
/**
 * @Author:kim
 * @Description: 利用反射获取成员变量
 * @DateTime: 2024/8/23 6:05
 **/
public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        /*
         *get表示获取
         *Declared表示私有
         *最后的s表示所有，复数形式
         *如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用
         * | Field[] getFields()  | 返回所有成员变量对象的数组（只能拿public的） 
         * | Field[] getDeclaredFields() | 返回所有成员变量对象的数组，存在就能拿到 
         * | Field getField(String name) | 返回单个成员变量对象（只能拿public的）   
         * | Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到 
         *
         * Field类用于创建对象的方法
         *   void set(Object obj,Object value):赋值
         *   Object get(Object obj)获取值
         */

        Class<?> cla = Class.forName("com.kim.reflact.field.Student");


        System.out.println("获取所有的成员变量，只是public");
        Field[] fields = cla.getFields();
        for (Field f : fields) {
            System.out.println(f);
            //public java.lang.String com.kim.reflact.field.Student.name
        }

        System.out.println("获取所有的成员变量，包括private");
        Field[] allFields = cla.getDeclaredFields();
        for (Field f : allFields) {
            System.out.println(f);
        }

        System.out.println("获取单个的成员变量，public");
        Field name = cla.getField("name");
        System.out.println(name);

        System.out.println("获取单个的成员变量，包括private");
        Field age = cla.getDeclaredField("age");
        System.out.println(age);


        System.out.println("-------------");
        //获取权限修饰符
        int modifiers = name.getModifiers();
        System.out.println(modifiers);//1 是API中设置的数字

        String n = name.getName();
        System.out.println(n);//name

        //获取数据类型
        Class<?> type = name.getType();
        System.out.println(type);//class java.lang.String

        //获取成员变量记录的值
        Student stu = new Student("zhangsan",12,"nv");
        //name.setAccessible(true);  若是私有 暴力反射
        String value = (String) name.get(stu);
        System.out.println(value);//zhangsan
        //进行修改
        name.set(stu,"张三");
        System.out.println(stu);
        //Student{name='张三', age=12, gender='nv'}
    }
}
```

**Method**

```java
package com.kim.reflact.methods;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

/**
 * @Author:kim
 * @Description: 利用反射获取成员方法
 * @DateTime: 2024/8/23 6:26
 **/
public class Demo {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {

        /*
         *  get表示获取
         *	Declared表示私有
         *	最后的s表示所有，复数形式
         *	如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用
         * | Method[] getMethods() | 返回所有成员方法对象的数组（只能拿public的） 
         * | Method[] getDeclaredMethods() | 返回所有成员方法对象的数组，存在就能拿到
         * | Method getMethod(String name, Class<?>... parameterTypes)| 返回单个成员方法对象（只能拿public的）
         * | Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到
         *
         *
         *  获取成员方法并运行
         *  方法
         *  Object invoke(Object obj, Object... args) ：运行方法
         * 参数一：用obj对象调用该方法
         * 参数二：调用方法的传递的参数（如果没有就不写）
         * 返回值：方法的返回值（如果没有就不写）
         */

        //1.获取字节码对象
        Class<?> cla = Class.forName("com.kim.reflact.methods.Student");

        System.out.println("获取里面所有的方法除了私有 【包括父类中所有的方法】:");
        Method[] methods = cla.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }

        System.out.println("获取里面所有的方法包括私有【没有父类的】:");
        Method[] methods2 = cla.getDeclaredMethods();
        for (Method method : methods2) {
            System.out.println(method);
        }

        System.out.println("获取指定的单个方法:");
        Method method = cla.getDeclaredMethod("eat",String.class);//方法的名称和参数列表，加参数列表是区别方法重载
        System.out.println(method);

        System.out.println("获取修饰符：");
        int modifiers = method.getModifiers();
        System.out.println(modifiers);

        System.out.println("获取方法名：");
        String name = method.getName();
        System.out.println(name);

        System.out.println("获取方法形参");
        Parameter[] parameters = method.getParameters();
        for (Parameter p: parameters) {
            System.out.println(p);
        }

        System.out.println("获取方法抛出的异常：");
        Class[] exceptionTypes = method.getExceptionTypes();
        for (Class c: exceptionTypes) {
            System.out.println(c);
        }

        System.out.println("方法运行起来");
        /*
         * 获取成员方法并运行
         *  方法
         *  Object invoke(Object obj, Object... args) ：运行方法
         * 参数一：用obj对象调用该方法
         * 参数二：调用方法的传递的参数（如果没有就不写）
         * 返回值：方法的返回值（如果没有就不写）
         */
        Student s = new Student();
        method.setAccessible(true);  //私有的需要 暴力反射
        String result =(String) method.invoke(s, "汉堡包");//方法的调用者 要传入的实际参数
        System.out.println(result);  //接收方法的返回值
    }
}
```

**作用 **

获取一个类里边所有的信息，获取到了之后，再执行其他的业务调用

结合配置文件，动态的创建对象并调用方法

**保存信息**

> 对于任意一个对象，都可以把对象所有字段名和值，保存到文件中去

```java
package com.kim.reflact.preatice.save;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;

/**
 * @Author:kim
 * @Description: 对于任意一个对象，都可以把对象所有字段名和值，保存到文件中去
 * @DateTime: 2024/8/23 7:01
 **/
public class MyReflectDemo {
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, IOException {

        Student s = new Student("小A",23,'女',167.5,"跳舞");
        Teacher t = new Teacher("大翔",11100);

        saveObject(s);
        /*System.out.println("老师：：：：：");
        saveObject(t);*/


        }
    public static void saveObject(Object obj) throws ClassNotFoundException, IllegalAccessException, IOException {
        //获取成员变量
        //Class<?> c = Class.forName("com.kim.reflact.preatice.save.Student");
        //麻烦，已经有变量了，直接用变量获取
        Class<?> c = obj.getClass();

        //创建IO流
        BufferedWriter bw = new BufferedWriter(new FileWriter("a.txt"));

        //获取所有的成员变量
        Field[] fields = c.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            //获取成员变量的名字  成员变量的值
            String name = field.getName();
            Object value = field.get(obj);
            //System.out.println("成员变量的名字："+name+"，值:"+value);
            //写出数据
            bw.write(name+"="+value);
            bw.newLine();
        }
        bw.close();
    }
}
```

**跟配置文件结合动态创建**

> 跟配置文件结合的方法，动态的创建对象，并调用方法

```properties
#创建classname类对象调用下面的方法
classname=com.kim.reflact.preatice.configFile.Teacher
method=teach
```

```java
package com.kim.reflact.preatice.configFile;

import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * @Author:kim
 * @Description: 跟配置文件结合的方法，动态的创建对象，并调用方法
 * @DateTime: 2024/8/23 7:31
 **/
public class MyReflectDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        /*
        * 反射可以与配置文件相结合的方式，根据全类名动态的创建对象，并调用方法
        * */

        //读取配置文件的信息   
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream("D:\\briup_study\\JD\\test\\prop.properties");
        prop.load(fis);
        //prop.load(new FileInputStream("D:\\briup_study\\JD\\test\\prop.properties"));
        System.out.println(fis);//java.io.FileInputStream@65ab7765
        fis.close();
        System.out.println("配置文件信息："+prop);
        //配置文件信息：{classname=com.kim.reflact.preatice.configFile.Student, method=study}


        //获取全类名及方法名
        String classname =(String) prop.get("classname");
        String method =(String) prop.get("method");
        System.out.println("全类名："+classname);
        System.out.println("方法名："+method);

        //利用反射创建对象并运行方法  获取构造方法在字节码文件里边
        Class<?> clazz = Class.forName(classname);
        Constructor con = clazz.getDeclaredConstructor();
        Object o = con.newInstance();
        System.out.println(o);//Teacher{name='null', salary=0.0}

        //clazz.newInstance(); 有横杠表示方法已经过时

        //获取成员方法并允许
        Method method1 = clazz.getDeclaredMethod(method);
        method1.setAccessible(true);
        method1.invoke(o);
        //要是调用老师的方法，什么都不需要改，只需要修改配置文件就好
    }
}
```

```java
/**
 * @Author:kim
 * @Description: 反射和配置文件结合动态获取的练习
 * @DateTime: 2024/8/23 10:00
 **/

/*  更有逻辑：
 * ①通过Properties加载配置文件
 * ②得到类名和方法名
 * ③通过类名反射得到Class对象
 * ④通过Class对象创建一个对象
 * ⑤通过Class对象得到方法
 * ⑥调用方法
 */
public class Demo3 {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        //①通过Properties加载配置文件
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream("D:\\briup_study\\JD\\test\\prop.properties");
        prop.load(fis);
        fis.close();
        System.out.println(prop);

        //②得到类名和方法名
        String className = prop.get("classname")+"";  //后面加引号就是转换为String类型
        String methodName = prop.get("method")+"";

        //③通过类名反射得到Class对象
        Class<?> clazz = Class.forName(className);

        //④通过Class对象创建一个对象(需要构造器)
        Constructor constructor = clazz.getConstructor();
        constructor.setAccessible(true);
        Object o = constructor.newInstance();

        //⑤通过Class对象得到方法(Method)
        Method method = clazz.getDeclaredMethod(methodName);
        method.setAccessible(true);

        //⑥调用方法
        method.invoke(o);
    }
}
```



## 面试题

**你觉得反射好不好？**

好，两个方面

1. 无视修饰符访问类中的内容。但这种操作在开发中一般不用，都是框架底层来用的。
2. 反射可以跟配置文件结合起来使用，动态的创建对象，动态的调用方法。

### 泛型擦除

**集合中的泛型只在java文件中存在，当编译成class文件之后，就没有泛型了**

> 这意味着在运行时，List<Integer> 和 List<String> 实际上都只是一个 List，并没有任何具体的类型信息。这种类型擦除使得泛型在运行时无法强制约束类型一致性。

```java
package com.kim.reflact.know;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

/**
 * @Author:kim
 * @Description: 若将下面案例改为<Integer> 编译通过但是运行报错  .class中没泛型，所以使用Object
 * @DateTime: 2024/8/23 9:29
 **/
public class Demo1 {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        ArrayList<String> list = new ArrayList<String>();
        list.add("a");

        //使用反射运行add方法去添加字符串
        Class clazz = list.getClass();
        //注意类型擦除，因为.class文件中没有泛型，所以都是Object.class
        //Method method = clazz.getMethod("add", String.class);
        Method method = clazz.getMethod("add", Object.class);

        method.invoke(list,"aaa");//[a, aaa]

        System.out.println(list);

        /*ArrayList<Integer> list2 = new ArrayList<>();
        list2.add(1);

        Class clazz2 = list2.getClass();
        Method method2 = clazz2.getMethod("add", Integer.class);
        method2.invoke(list2, 1);
        System.out.println(list);*/
    }
}
```

### 修改字符串内容（为什么字符串不能修改）

```
private final byte[] value;  //底层的一个byte类型的字节数组
```

final与private

> final修饰 表示value记录的地址值不能修改
>
> private  修饰value而且没有对外提供getvalue和setvalue的方法。所以，在外界不能获取或修改value记录的地址值。

强行修改用反射

```java
package com.kim.reflact.know;

import java.lang.reflect.Field;

/**
 * @Author:kim
 * @Description: 字符串也是一个对象  变量value
 * @DateTime: 2024/8/23 9:46
 **/
public class Demo2 {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        String s = "abc";
        String ss = "abc";
// private final byte[] value= {97,98,99};
// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值
// 如果我们利用反射获取了value的地址值。
// 也是可以修改的，final修饰的value
// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险
        
        //1.获取.class对象
        Class clazz = s.getClass();
        //2.获取value成员变量
        Field f = clazz.getDeclaredField("value");
        //这种操作非常危险 JDK高版本已经屏蔽
        //临时修改权限
        f.setAccessible(true);
        //3.获取value记录的地址值
        byte[] bytes = (byte[]) f.get(s);
        bytes[0]=100;

        System.out.println(s);//dbc
        System.out.println(ss);//abc
    }
}
```

