**不可变类**

标准库中 

```
Srting 字符串   一旦创建，其内容不能被改变，每次修改都会创建一个新的“String”对象
Integer、Character等包装类   它们的值一旦被赋值就不能更改。
LocalData、LocalTime等日期和时间类  Java8开始，这些类提供了对日期和时间的操作功能，同时保证了对象的不可变性
Path文件的路径    每次对路径的操作都会返回一个新的`path`对象
URI和URL
```

> 用处
> 1.线程安全性，避免了建设同步机制
>
> 2.不用担心对象被修改，简化了维护
>
> 3.缓存和优化问题
>
> 4.可以用作键值对

自定义不可变类

```
类声明为final 防止继承
所有字段为private 和 final  只能初始化一次，外部类无法直接访问或修改
没有提供setter方法 不能修改对象的状态
初始化所有字段：确保所有字段在对象构造时被完全初始化 构造函数
确保对象状态不可变：若类包含可变对象，如数组或集合，必须采取额外步骤来确保对象的不可变性，这通过创建字段的深拷贝来实现，或者通过将其设计为不可变类型。
```

```
public ImmutableBook(String title, List<String> authors) {
        this.title = title;
        // 创建集合的防修改视图来确保不可变性
        this.authors = new ArrayList<>(authors);
        // 使用不可变集合视图
        this.authors = Collections.unmodifiableList(this.authors);
    }

```

**深拷贝与浅拷贝**

**浅拷贝**:

- 复制对象，但对引用类型字段仅复制引用。
- 修改拷贝对象中的引用字段会影响原对象中的相应字段。

```java
public class ShallowCopyExample implements Cloneable {
    private int[] array;

    public ShallowCopyExample(int[] array) {
        this.array = array;
    }
    /*
     重点：仅仅复制了它的引用，没有复制它的内容，所以对对象中的数组进行修改也会影响原对象中的数组。
    */
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public int[] getArray() {
        return array;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        int[] originalArray = {1, 2, 3};
        ShallowCopyExample original = new ShallowCopyExample(originalArray);

        ShallowCopyExample copy = (ShallowCopyExample) original.clone();
        copy.getArray()[0] = 99; // 修改拷贝对象中的数组

        System.out.println("Original array: " + original.getArray()[0]); // 输出: 99
        System.out.println("Copied array: " + copy.getArray()[0]); // 输出: 99
    }
}
```

**深拷贝**:

- 递归复制对象及其引用的所有对象。
- 拷贝对象与原对象完全独立，修改拷贝对象中的内容不会影响原对象。

```java
import java.util.Arrays;

public class DeepCopyExample implements Cloneable {
    private int[] array;

    public DeepCopyExample(int[] array) {
        this.array = array.clone(); // 使用 clone 方法来创建数组的副本
    }

    /**
    重点：创建了一个新的copy 用来存储数组，并且构造方法复制了数组的内容
    */
    @Override
    public Object clone() throws CloneNotSupportedException {
        DeepCopyExample copy = (DeepCopyExample) super.clone();
        copy.array = this.array.clone(); // 创建数组的深拷贝
        return copy;
    }

    public int[] getArray() {
        return array;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        int[] originalArray = {1, 2, 3};
        DeepCopyExample original = new DeepCopyExample(originalArray);

        DeepCopyExample copy = (DeepCopyExample) original.clone();
        copy.getArray()[0] = 99; // 修改拷贝对象中的数组

        System.out.println("Original array: " + original.getArray()[0]); // 输出: 1
        System.out.println("Copied array: " + copy.getArray()[0]); // 输出: 99
    }
}
```

**序列化与反序列化**

序列化：将对象的状态转换为字节流的过程。

> 被保存到文件或发送到网络中，或传递到其他JVM实例

反序列化：就是将字节流转换回对象的过程。

实现序列化的类需要实现 `Serializable` 接口，并且可以通过 `ObjectOutputStream` 和 `ObjectInputStream` 进行对象的序列化和反序列化。

```
private static final long serialVersionUID = 1L;//唯一标识，确保序列化与反序列化时的版本兼容。
```

**处理字符串的三种不同的类**

```
String 1.不可变性(final) 2.性能：每次连接字符串都会创建新的`String`对象 3.不可变-线程安全
```

```
StringBuffer 1.可变性 2.线程安全，它的公共方法都是同步的 
```

```
StringBuilder 1.可变性 2.线程不安全(所以在单线程比StringBuffer高效)  这个ArrayList与Vector
```

**StringBuilder的实现**

```java
public class MyStringBuilder {
    private char[] value;   //基于一个可变数组
    private int count;   //动态调整大小

    public MyStringBuilder() {
        this.value = new char[16]; // 默认初始容量
        this.count = 0;
    }

    public MyStringBuilder append(String str) {
        if (str == null) {
            str = "null";
        }
        int len = str.length();
        ensureCapacity(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }

    //扩展机制
    private void ensureCapacity(int minimumCapacity) {
        if (minimumCapacity > value.length) {
            int newCapacity = Math.max(value.length * 2, minimumCapacity);
            //两倍
            value = Arrays.copyOf(value, newCapacity);
        }
    }

    public String toString() {
        return new String(value, 0, count);
    }
}
```

```
常用方法：可以在指定位置进行操作
append(): 追加字符、字符串或其他数据类型。
insert(): 在指定位置插入字符或字符串。
delete(): 删除指定范围内的字符。
reverse(): 反转字符序列。
toString(): 将 StringBuilder 的内容转换为 String。
```

**对比String类中的常用方法**

```java
//长度
length()
//子字符串
subString(int beginIndex)   //>=
String substring(int beginIndex, int endIndex)//[)
//字符查找
int indexOf(String str)   //返回指定字符或子字符串第一次出现的索引位置。
int indexOf(char ch)      //如果未找到，则返回 -1
int indexOf(String str, int fromIndex)
int indexOf(char ch, int fromIndex)     
//字符串替换
String replace(char oldChar, char newChar)  //str.replace('o','0');将o换为0
String replace(CharSequence target, CharSequence replacement)//str.replace('World','Java');
//字符串分割
String[] split(String regex)
String[] split(String regex, int limit)
//前后空白去除
String trim()
//转换大小写
String toLowerCase()
String toUpperCase()
```

**==与equals（）**

1. 基本数据类型
   - == 它们的值相等true,否则false
   - equals()方法不存在，基本类型不是对象，只能使用==
2. 引用是数据类型
   - == 两个对象的内存地址（即引用）
   - equals() 默认比较对象内存地址，重写便比较实际内容。默认重新的类(String Integer Double Boolean Character LocalDate日期时间等Java8+

**hashCode()` 和 `equals()` 的重要性**

- **`hashCode()`**: 用于生成对象的哈希码，哈希码决定了对象在哈希表中的位置。确保 `hashCode()` 方法生成的哈希码均匀分布，可以减少冲突。
- **`equals()`**: 当哈希码相同的对象存储在同一个桶中时，`equals()` 方法用于比较对象的实际内容，以确保正确的对象访问。

```
equals相同时hashcode一定相同，但hashcode相等但是equals不一定相同，只能说明他们存贮在散射存储结构中的同一个位置：实这里是因为hash表的有限性和对象的潜在无限性，所以不同对象有相同的hash值的情况不可避免，这种情况叫做哈希冲突，但是即便这种情况下还是能区分的，这里使用的是  链地址法  ，就是会在内部使用一个链表来存储这些hash冲突的元素，在查找元素的时候会遍历这些链表，用equals方法来找到正确的值
所有在
```

> 为什么在重写 `equals()` 时也应该重写 `hashCode()` ？
>
> 1. 保持一致性：
>
>    - **`equals()` 和 `hashCode()` 的契约**:
>      - 如果两个对象通过 `equals()` 方法比较相等，则这两个对象的 `hashCode()` 方法必须返回相同的整数值。这个契约是 `java.lang.Object` 类所定义的，并且被哈希表（如 `HashMap`）等数据结构所依赖。
>      - 如果不遵守这个契约，可能会导致哈希表中的问题，比如对象不能正确地插入、查找或删除。
>
> 2. 数据结构的一致性
>
>    - 哈希表（如 `HashMap`, `HashSet`）
>      - 哈希表使用 `hashCode()` 来确定对象的存储位置。如果两个对象的 `hashCode()` 不一致，哈希表可能会将这些对象存储在不同的桶中，即使它们通过 `equals()` 方法被认为是相等的。这会导致无法通过查找找到这些对象，影响数据结构的正确性。
>
>    3. **性能**
>
>    - 高效的查找和存储：
>      - `hashCode()` 的实现直接影响哈希表的性能。如果哈希码分布均匀，可以减少冲突，提高操作效率。尽管重写 `hashCode()` 的主要目的是确保 `equals()` 相等的对象具有相同的哈希码，但合理的 `hashCode()` 实现也有助于提高数据结构的性能。

![image-20240821101816916](D:\briup_study\JD\Java基础&高级笔记\集合.assets\image-20240821101816916.png)