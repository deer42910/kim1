关于接口

比如在看Map接口的源码时发现为什么方法会有具体实现

Java8开始，接口可以包含默认方法和静态方法，这些方法可以有具体的实现。

**default methods**在不破坏现有实现类的情况下，为接口添加新的功能

```
default void forEach(BiConsumer<? super K, ? super V> action) {
    Objects.requireNonNull(action);
    for (Entry<K, V> entry : entrySet())
        action.accept(entry.getKey(), entry.getValue());//对每个元素应用操作的实现
}
```

**static methods**方法属于接口本身，而不是任何实现接口的对象

```
static <K, V> Map.Entry<K, V> entry(K key, V value) {
    return new SimpleEntry<>(key, value);
}//用于创建Map.Entry对象。
```

**面试题**

若两个接口中存在相同的default方法定义，那么子类在实现这两个接口的时候，就要对这个方法进行重写。

```
@Override
    public void demo() {
        SonInterface.super.demo();//接口名.super.方法名;
    }
```

若不重写

```
SonInterface 中的 demo 方法覆盖了 ParentInterface 中的同名方法，因此最终输出 SonInterface 
```

**函数式接口**

jdk8中，接口有且只有一个抽象方法

```
@FunctionInterface
1、标识某个函数式接口（提升可读性）
2.检查这个接口是否是函数式接口
若不具备这个特征，加注解后会报错，就类似于检查重写的@Overible
```

**四大函数式接口**

```
package java.util.function;
```

**Consumer **消费型接口

```
void accept(T t);
有参数 无返回值
//接受一个参数并没有返回值。用于执行操作
Consumer<String> print = s -> System.out.println(s);
```

**Suplier** 供给型

```
T get();
无参数 有返回值
//不接受参数并返回一个结果。用于提供数据。
Supplier<Double> randomValue = () -> Math.random();
```

**Function** 函数型

```
R apply(T t);
有参数 也有返回值
//Function<T, R>: 接受一个参数并返回一个结果。用于将输入映射到输出。
Function<String, Integer> stringLength = s -> s.length();
```

**Predicate**断言型

```
boolean test(T t);
做判断，有参数 有返回值(固定的boolean类型)
//Predicate<T>: 接受一个参数并返回一个布尔值。用于测试条件。
Predicate<Integer> isEven = x -> x % 2 == 0;
```

**其它**

**UnaryOperator<T>**接受一个参数并返回一个结果，类型相同。继承自 `Function<T, T>`。

```java
UnaryOperator<Integer> square = x->x*x;
```

**BinaryOperator<T>**:接受两个参数并返回一个结果，类型相同。继承自 `BiFunction<T, T, T>`

```
BinaryOperator<Integer> add = (x,y)->x+y;
```

